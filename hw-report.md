Markdown report <br>

1. Ганина Ксения Андреевна <br>
2. БПИ212 <br>
3. В-13 <br>
4. Тесты, демонстрирующие проверку программ. <br>
5. Результаты тестовых прогонов для различных исходных данных. <br>
6. Исходные тексты программы на языке C. <br>
7. Тексты программы на языке ассемблера, разработанной вручную или полученной после компиляции и расширенной комментариями. <br>
8. Текст на ассемблере программы, полученный после компиляции программы на C. <br>
9. Информацию, подтверждающую выполнение задания в соответствие требованиям на предполагаемую оценку. <br>

![image](https://user-images.githubusercontent.com/114473740/197335272-b4a5eef8-d401-4dce-ad53-26b7bfa52687.png) <br>

должна быть прога на си, скомпелированная gcc с флагами и без них + вылизанная скомпиленная прога <br>

5 <br>
Аргументы в функцию передаются через регистры в следующем порядке: ... <br>
Возвращаемое из функции значение лежит в регистре rax (считываем результат выполнения функции из rax) <br>
при вызове функции перекладываются агрументы на стек (первый аргумент argc) <br>

6 <br>
рефакторинг -- gcc всё кидает на стек, а это не нужно, заменяем регистры, где надо (и указываем), <br>
проверяем, что всё работает так же верно, как и раньше <br>
находить эквиваленты между строками кода на си и на асме <br>

7 <br>
пишем все функции по отдельным файлам (получается несколько единиц компиляции) <br>

8 <br>
ввод данных либо из командной строки, либо из файла, либо с использованием генератора <br>
вывести время работы проги ●●

9 <br>
скомпилить с O2 (+ флагами на оптимизацию и флагами на размер), <br>
сравнить по размерам исполняемых файлов, размеру асм кода и производительности (время работы, скорость исполнения) <br>
//можно табличку: моя, без оптима, с оптимом по размеру <br>
//можно не анализировать код после полученного оптимизатора! <br>


________________________

формат ввода данных <br>
argc -- число аргументов в функции (если  1), значит, передали аргументы <br>
argv -- массив с аргументами, где: <br>
argv[0] -- формат ввода (1 -- console, 2 -- file, else -- random generation) <br>
выводится в консоль и в файл "output.txt" <br>


компиляция кусков кода и линковка: <br>

`gcc -masm=intel \
    -fno-asynchronous-unwind-tables \
    -fno-jump-tables \
    -fno-stack-protector \
    -fno-exceptions \
    ./main.c \
    -S -o ./main.s`
<br>
`gcc ./main.s -c -o ./main.o`

command_line_input.c <br>
command_line_output.c <br>
count_if_equals_element.c <br>
file_input.c <br>
file_output.c <br>
fill_ARRAY_B.c <br>
get_min_from_array.c <br>
random_generation.c <br>
timespec_difference.c <br>

`gcc -lc main.o command_line_input.o command_line_output.o count_if_equals_element.o file_input.o file_output.o fill_ARRAY_B.o get_min_from_array.o random_generation.o timespec_difference.o -o foo.exe`

Убираем макросы: <br>
endbr64 <br>


Переписываем .section.data для наглядности <br>

Изменения main: <br>
Убираем лишние присваивания: вместо  <br>
`mov	rax, QWORD PTR -8[rbp]` <br>
`mov	rdi, rax` <br>
сразу пишем <br>
`mov	rdi, QWORD PTR -8[rbp]` <br>

Также добавилось небольшое отличие от программы на Си — вывод `elapsed_ns` после вывода массивов (чтобы при генерации массивов время было видно) <br>
